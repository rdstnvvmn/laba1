//Хромой король.На квадратной доске в каждой клетке короля ожидают неприятности в количестве 
//от 0 до 30. Хромой король, находящийся в правом верхнем углу, мечтает попасть в левый нижний 
//угол.При этом он может передвигаться только в клетку слева или снизу и хочет, чтобы сумма 
//всех неприятностей, оказавшихся у него на пути, была бы минимальной.
//Определить эту сумму и путь, каким образом должен двигаться король.Ввод и вывод организовать 
//при помощи текстовых файлов.Формат входных данных : в первой строке входного файла
//записано число N - размер доски(1 < N < 80).Далее следует N строк, каждая из которых содержит
//N чисел - количество неприятностей в клетках доски.В первую строку выходного файл нужно
//вывести единственное число : минимальную сумму, а во второй строке вывести путь в виде
//строки символов, обозначив символом L движение влево, а символом D - движение вниз.

#include <iostream> 
#include <fstream>  
#include <vector>    
#include <algorithm> 

using namespace std;

int main() {
    ifstream inputFile("input1.txt");
    ofstream outputFile("output1.txt");

    if (!inputFile.is_open()) {
        cerr << "Не удалось открыть входной файл!" << endl;
        return 1;
    }

    if (!outputFile.is_open()) {
        cerr << "Не удалось открыть выходной файл!" << endl;
        inputFile.close();
        return 1;
    }

    int n;
    inputFile >> n;

    vector<vector<int>> board(n, vector<int>(n)); // Создает двумерный вектор (матрицу) board размера n x n для хранения значений доски.
    for (int i = 0; i < n; ++i) { // Цикл по строкам доски.
        for (int j = 0; j < n; ++j) { // Цикл по столбцам доски.
            inputFile >> board[i][j]; 
        }
    }

    inputFile.close();


    vector<vector<int>> dp(n, vector<int>(n, 0)); // хранит минимальную сумму неприятностей для достижения клетки (i, j).
    vector<vector<char>> path(n, vector<char>(n, ' '));//path[i][j] хранит символ 'L' (влево) или 'D' (вниз), указывающий, откуда мы пришли в клетку (i, j).


    dp[0][n - 1] = board[0][n - 1]; 

    // Заполняем первый столбец (движение только вниз):
    for (int i = 1; i < n; ++i) {
        dp[i][n - 1] = dp[i - 1][n - 1] + board[i][n - 1]; 
        path[i][n - 1] = 'D'; 
    }

    // Заполняем первую строку (движение только влево):
    for (int j = n - 2; j >= 0; --j) { 
        dp[0][j] = dp[0][j + 1] + board[0][j]; 
        path[0][j] = 'L'; // Записывает 'L' в path, указывая, что мы пришли в эту клетку справа.
    }

    // Заполняем оставшуюся часть
    for (int i = 1; i < n; ++i) { 
        for (int j = n - 2; j >= 0; --j) { 
            if (dp[i - 1][j] < dp[i][j + 1]) { // Проверяет, какой путь лучше: сверху или справа.
                dp[i][j] = dp[i - 1][j] + board[i][j]; 
                path[i][j] = 'D'; 
            }
            else { 
                dp[i][j] = dp[i][j + 1] + board[i][j]; 
                path[i][j] = 'L'; 
            }
        }
    }

    // Восстановление пути:
    string route = ""; 
    int row = n - 1; 
    int col = 0;     

    while (row != 0 || col != n - 1) { 
        route += path[row][col]; 
        if (path[row][col] == 'D') { 
            row--; 
        }
        else { 
            col++; 
        }
    }

    reverse(route.begin(), route.end()); // Переворачивает строку route, чтобы получить путь от правой верхней клетки к левой нижней.

    outputFile << dp[n - 1][0] << endl; // Записывает минимальную сумму (dp[n - 1][0]) в файл "output1.txt".
    outputFile << route << endl; // Записывает маршрут (route) в файл "output1.txt".

    outputFile.close();

    return 0;
}